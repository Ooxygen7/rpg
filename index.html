<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Top-down Tech Tank — 直升机连发装弹 · 碉堡旋转炮塔 · 移动端轮盘</title>
<style>
  html, body { height: 100%; margin: 0; background:#0d0f13; color:#dfe7ef; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
  #game { position: fixed; inset: 0; display:block; }
  .hud { position: fixed; left: 16px; top: 16px; user-select:none; pointer-events:none; font-size:14px; line-height:1.2; color:#eaf2ff; text-shadow:0 1px 0 rgba(0,0,0,.5); }
  .hud .panel { background: rgba(12,16,24,.55); border:1px solid rgba(255,255,255,.08); box-shadow:0 8px 24px rgba(0,0,0,.35), inset 0 0 30px rgba(255,255,255,.04); border-radius:12px; padding:10px 12px; }
  .right { position: fixed; right: 16px; top: 216px; }
  .legend { position: fixed; left: 16px; bottom: 16px; background: rgba(15,19,28,.55); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; font-size:13px; pointer-events:none; }
  .ammoBar { display:flex; gap:6px; margin-top:6px; }
  .ammoSlot { width:16px; height:26px; border-radius:4px; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.12); position:relative; overflow:hidden; }
  .ammoFill { position:absolute; left:0; bottom:0; width:100%; background:#8ad2ff; }
  .badge { display:inline-block; padding:2px 6px; border-radius:999px; background:#1b2332; border:1px solid rgba(255,255,255,.12); margin-left:6px; font-size:12px; }
  .mini { position: fixed; right: 16px; top: 16px; width: 180px; height: 180px; pointer-events:none; }
  #minimap { width: 100%; height: 100%; display:block; filter: drop-shadow(0 8px 16px rgba(0,0,0,.35)); border-radius:12px; border:1px solid rgba(255,255,255,.1); background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)); }

  /* 移动端轮盘 */
  .touch-ui { position:fixed; inset:0; pointer-events:none; }
  .joy { position:absolute; width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); box-shadow:0 8px 24px rgba(0,0,0,0.35); pointer-events:auto; touch-action:none; }
  .joy .knob { position:absolute; left:50%; top:50%; width:64px; height:64px; margin-left:-32px; margin-top:-32px; border-radius:50%; background:rgba(255,255,255,0.12); border:1px solid rgba(255,255,255,0.2); }
  .joy .label { position:absolute; bottom:-22px; left:50%; transform:translateX(-50%); font-size:12px; color:#cfe3ff; text-shadow:0 1px 0 rgba(0,0,0,.6); pointer-events:none; }
  .joy.disabled { opacity:.5; filter:grayscale(1); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="hud">
  <div class="panel">
    <div>GAU-8 预热：<span id="spinPct">0%</span> <span class="badge">左键长按</span></div>
    <div style="width:220px;height:8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);margin-top:6px;background:rgba(255,255,255,.06);">
      <div id="spinBar" style="height:100%;width:0%;border-radius:999px;background:linear-gradient(90deg,#ffd36a,#fff2a6);"></div>
    </div>
    <div style="margin-top:10px;">火箭弹：<span id="rocketCount">5</span> / 5 <span class="badge">右键</span></div>
    <div class="ammoBar" id="rocketSlots"></div>
    <div style="margin-top:10px;">榴弹 <span class="badge">Q 指示器 → 左键发射</span></div>
    <div style="margin-top:6px;"><small>Q 冷却：<span id="qCooldown">就绪</span></small></div>
    <div style="margin-top:10px;">震撼弹 <span class="badge">E 指示器 → 左键</span></div>
  </div>
</div>

<div class="legend">
  <div><strong>W/A/S/D</strong> 移动（底盘朝移动方向）；<strong>鼠标</strong> 控炮塔；<strong>左键</strong> GAU-8；<strong>右键</strong> 火箭；<strong>Q</strong> 指示器→左键抛射榴弹（穿墙，30s 冷却）；<strong>E</strong> 指示器→左键闪光震撼弹（穿墙，5s 眩晕 + 1 伤害）</div>
</div>
<div class="right panel hud"><small>直升机连发 7 → 装弹 2s · 碉堡可动旋转炮塔 · 移动端轮盘</small></div>
<div class="mini"><canvas id="minimap" width="180" height="180"></canvas></div>

<!-- 触屏 UI 容器（按需显示） -->
<div id="touchUI" class="touch-ui" style="display:none;"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  let W = 0, H = 0;

  /* ====== 提前声明，防止 TDZ ====== */
  const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);
  const touchMove = {el:null, knob:null, active:false, vec:{x:0,y:0}};
  const touchFire = {el:null, knob:null, active:false, vec:{x:0,y:0}};
  const touchQ    = {el:null, knob:null, active:false, vec:{x:0,y:0}, preview:false};
  const touchE    = {el:null, knob:null, active:false, vec:{x:0,y:0}, preview:false};
  let touchPreviewWorld = {x:0,y:0};

  /* 关键：音频标志提前初始化 */
  let AC = null, noiseBuf = null, audioInited = false;

  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    positionTouchUI(); // 此时 isTouch 与触控对象已存在，避免 TDZ
  }
  window.addEventListener('resize', resize);
  resize();
  window.addEventListener('contextmenu', e => e.preventDefault());

  // ---------- Utils ----------
  const TAU = Math.PI * 2;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a=0,b=1)=>Math.random()*(b-a)+a;
  const randInt=(a,b)=>Math.floor(rand(a,b+1));
  const vec2 = (x=0,y=0)=>({x,y});
  const vadd=(a,b)=>({x:a.x+b.x,y:a.y+b.y});
  const vsub=(a,b)=>({x:a.x-b.x,y:a.y-b.y});
  const vmul=(a,s)=>({x:a.x*s,y:a.y*s});
  const vlen=a=>Math.hypot(a.x,a.y);
  const vnorm=a=>{const l=vlen(a)||1;return {x:a.x/l, y:a.y/l}};
  const angleLerp=(a,b,t)=>{let d=((b-a+Math.PI*3)%(TAU))-Math.PI;return a+d*t;};

  const TILE=40, MAP_TILES=120, MAP_W=TILE*MAP_TILES, MAP_H=TILE*MAP_TILES;
  const SCALE = 0.7;
  const cam = {x: MAP_W/2, y: MAP_H/2};
  const worldToScreen = (p)=>({x: (p.x - cam.x) + W/2, y: (p.y - cam.y) + H/2});
  const screenToWorld = (p)=>({x: cam.x + (p.x - W/2), y: cam.y + (p.y - H/2)});

  // ---------- Input ----------
  const mouse = {x: W/2, y: H/2, left:false, right:false}; let mouseWorld = {x:MAP_W/2, y:MAP_H/2};
  const keys = new Set();
  window.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; mouseWorld = screenToWorld({x:mouse.x, y:mouse.y}); });
  let grenadeTargeting=false, eTargeting=false;
  window.addEventListener('mousedown', e => {
    if (e.button===0) mouse.left=true; if (e.button===2) mouse.right=true;
    if (grenadeTargeting && e.button===0) { const t = clampToRange(mouseWorld, player.pos, grenadeRange); fireGrenadeTo(t.x,t.y); grenadeTargeting=false; qCooldown=30; sfxGrenadeThrow(); initAudio(); }
    else if (eTargeting && e.button===0) { const t = clampToRange(mouseWorld, player.pos, grenadeRange); fireFlashbangTo(t.x,t.y); eTargeting=false; sfxFlashThrow(); initAudio(); }
    initAudio();
  });
  window.addEventListener('mouseup', e => { if (e.button===0) mouse.left=false; if (e.button===2) mouse.right=false; });
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    keys.add(k);
    if (k==='q') { if (!grenadeTargeting && qCooldown<=0) grenadeTargeting = true; else if (grenadeTargeting) grenadeTargeting=false; }
    if (k==='e') { eTargeting = !eTargeting; }
  });
  window.addEventListener('keyup', e => { keys.delete(e.key.toLowerCase()); });

  // ---------- World ----------
  const world = {
    bullets: [],
    particles: [],
    rockets: [],
    grenades: [],
    bomblets: [],
    flashbangs: [],
    eGrenades: [],
    eBullets: [],
    eRockets: [], // 敌方直升机火箭弹（到点爆）
    enemies: [],
    shockwaves: [],
    time: 0,
  };

  const player = {
    pos: vec2(MAP_W/2, MAP_H/2),
    vel: vec2(0,0),
    speed: 260,
    baseAngle: 0,   // 底盘
    turretAngle: 0, // 炮塔
    spin: 0, spinUp: 3.0, spinDown: 0.7, fireCooldown: 0,
    minRPM: 120, maxRPM: 4200,
    trackScroll: 0,
    hp: 300,
    radius: 18*SCALE
  };

  // Rockets
  let rocketAmmo = 5, rocketReloadAcc = 0;
  const rocketReloadInterval = 20, rocketMagazine = 5;

  // Q / E （半径缩为 2/3）
  const grenadeRange = Math.floor(800 * 2/3);   // 533
  const GRENADE_BLAST = Math.floor(80 * 2/3);   // ~53
  const FLASH_BLAST = Math.floor(120 * 2/3);    // 80
  const BOMBLET_BLAST = Math.floor(70 * 2/3);   // ~46
  const ENEMY_GRENADE_R = 24; // 敌方步兵手雷爆炸半径（原 120 的 1/5）

  // Shake
  let shake = 0; function addShake(s){ shake = Math.min(18, shake + s); }

  // ---------- City ----------
  const city = {buildings: [], roads: []};
  const TYPES = {
    heavy_tank: {hp: 900, speed: 70,  r: 28*SCALE, cannonCD: 3.2, mgCD: 0.1},
    light_tank: {hp: 520, speed: 110, r: 24*SCALE, autoCD: 0.07, mgCD: 0.18},
    bunker:     {hp: 850, speed: 40,  r: 26*SCALE, mgCD: 0.06, turretRate: 0.6},
    infantry:   {hp: 60,  speed: 120, r: 12*SCALE, rifleCD: 0.6},
    heli:       {hp: Math.round(520*0.8), speed: 200, r: 22*SCALE, rocketCD: 0.10, burst:7, reload:2.0} // 单发快速 + 7连发 → 2s 装弹
  };
  const BUILDING_HP = TYPES.heavy_tank.hp * 5; // 4500

  function getBuildingHeight(type){
    switch(type){
      case 'residential': return randInt(6,10);
      case 'industrial': return randInt(8,12);
      case 'office':     return randInt(10,16);
      case 'mall':       return randInt(9,13);
      case 'skyscraper': return randInt(18,28);
      case 'ruin':       return randInt(5,9);
      default: return 10;
    }
  }

  function buildRoads(){
    city.roads = [
      {x:0,           y:MAP_H*0.45, w:MAP_W,  h:104},
      {x:MAP_W*0.45,  y:0,          w:104,    h:MAP_H},
      {x:0,           y:MAP_H*0.25, w:MAP_W,  h:72},
      {x:MAP_W*0.25,  y:0,          w:72,     h:MAP_H},
    ];
  }
  buildRoads();

  // ---- geometry helpers ----
  function rectsOverlap(a,b,margin=0){
    return !(a.x+a.w <= b.x+margin || a.x >= b.x+b.w-margin || a.y+a.h <= b.y+margin || a.y >= b.y+b.h-margin);
  }
  function pointInRect(x,y,b){ return x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h; }
  function collidesCircleRect(cx,cy,r,b){
    const nx = clamp(cx, b.x, b.x+b.w), ny = clamp(cy, b.y, b.y+b.h);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }
  function segIntersectsRect(p1, p2, r){
    if (pointInRect(p1.x,p1.y,r) || pointInRect(p2.x,p2.y,r)) return true;
    const edges = [
      [{x:r.x,y:r.y},{x:r.x+r.w,y:r.y}],
      [{x:r.x+r.w,y:r.y},{x:r.x+r.w,y:r.y+r.h}],
      [{x:r.x+r.w,y:r.y+r.h},{x:r.x,y:r.y+r.h}],
      [{x:r.x,y:r.y+r.h},{x:r.x,y:r.y}]
    ];
    for (const [a,b] of edges){ if (segmentsIntersect(p1,p2,a,b)) return true; }
    return false;
  }
  function orientation(a,b,c){ const v=(b.y-a.y)*(c.x-b.x)-(b.x-a.x)*(c.y-b.y); if (Math.abs(v)<1e-9) return 0; return v>0?1:2; }
  function onSeg(a,b,c){ return Math.min(a.x,b.x)-1e-9<=c.x && c.x<=Math.max(a.x,b.x)+1e-9 && Math.min(a.y,b.y)-1e-9<=c.y && c.y<=Math.max(a.y,b.y)+1e-9; }
  function segmentsIntersect(p1,q1,p2,q2){
    const o1=orientation(p1,q1,p2), o2=orientation(p1,q1,q2), o3=orientation(p2,q2,p1), o4=orientation(p2,q2,q1);
    if (o1!==o2 && o3!==o4) return true;
    if (o1===0 && onSeg(p1,q1,p2)) return true;
    if (o2===0 && onSeg(p1,q1,q2)) return true;
    if (o3===0 && onSeg(p2,q2,p1)) return true;
    if (o4===0 && onSeg(p2,q2,q1)) return true;
    return false;
  }
  function hasLineOfSight(a,b){
    for (const br of city.buildings){ if (segIntersectsRect(a,b,br)) return false; }
    return true;
  }

  // ---- buildings ----
  function buildCity(){
    city.buildings = [];
    const SIZE_SCALE = 4;
    const margin=40, maxTries=2400, minGap=12;
    const types = ['residential','industrial','skyscraper','office','mall','ruin'];
    let tries=0;
    const targetCount = 140;
    while (tries++<maxTries && city.buildings.length<targetCount){
      const w = randInt(60,130) * SIZE_SCALE;
      const h = randInt(60,130) * SIZE_SCALE;
      const x = clamp(randInt(margin, MAP_W - margin - w), 0, MAP_W - w);
      const y = clamp(randInt(margin, MAP_H - margin - h), 0, MAP_H - h);
      const type = types[randInt(0,types.length-1)];
      const cand = {x,y,w,h, hp:BUILDING_HP, type, elev: getBuildingHeight(type)};
      let bad=false;
      for (const rd of city.roads){ if (rectsOverlap(cand, rd, 12)) { bad=true; break; } }
      if (bad) continue;
      for (const b of city.buildings){ if (rectsOverlap(cand, b, minGap)) { bad=true; break; } }
      if (bad) continue;
      city.buildings.push(cand);
    }
  }
  buildCity();

  function randomOpenSpot(radius){
    for (let i=0;i<5000;i++){
      const x = randInt(40, MAP_W-40), y = randInt(40, MAP_H-40);
      let ok = true;
      for (const b of city.buildings){ if (collidesCircleRect(x,y,radius,b)) { ok=false; break; } }
      if (ok) return {x,y};
    }
    return {x:MAP_W/2,y:MAP_H/2};
  }

  // ---------- Weapons ----------
  function getGunPoints(){
    const dir = {x: Math.cos(player.turretAngle), y: Math.sin(player.turretAngle)};
    const muzzle = vadd(player.pos, vmul(dir, 44*SCALE));
    return {dir, muzzle};
  }
  function fireGAU8(dt) {
    if (mouse.left) player.spin = clamp(player.spin + dt / player.spinUp, 0, 1);
    else player.spin = clamp(player.spin - dt / player.spinDown, 0, 1);
    const rpm = lerp(player.minRPM, player.maxRPM, player.spin);
    const rps = rpm / 60;
    const shotsInterval = (rps>0)?(1 / rps):1e9;
    if (mouse.left && player.spin > 0.08) {
      player.fireCooldown -= dt;
      while (player.fireCooldown <= 0) {
        player.fireCooldown += shotsInterval;
        spawnBullet(); sfxGAU(player.spin);
      }
      addShake(0.18); spawnMuzzleFlash();
    } else { player.fireCooldown = 0; }
    document.getElementById('spinPct').textContent = Math.round(player.spin*100) + '%';
    document.getElementById('spinBar').style.width = (player.spin*100) + '%';
  }
  function spawnBullet(){
    const {dir, muzzle} = getGunPoints();
    const ang = Math.atan2(dir.y, dir.x) + rand(-0.01, 0.01);
    const speed = 1600;
    const vel = {x: Math.cos(ang)*speed, y: Math.sin(ang)*speed};
    world.bullets.push({pos: {...muzzle}, vel, life: 1.0, length: 22, dmg: 5.5});
    addShake(0.35);
  }
  function spawnMuzzleFlash(){
    const {dir, muzzle} = getGunPoints();
    for (let i=0;i<4;i++) {
      const ang = Math.atan2(dir.y,dir.x) + rand(-0.7,0.7);
      const pdir = {x:Math.cos(ang), y:Math.sin(ang)};
      world.particles.push({ pos: {...muzzle}, vel: vmul(pdir, rand(120, 300)), life: rand(0.04, 0.12), size: rand(2,5), color: 'rgba(255,210,90,', glow: true });
    }
  }
  function fireRocket(){
    if (rocketAmmo<=0) return;
    rocketAmmo--; updateRocketHUD();
    const {dir, muzzle} = getGunPoints();
    const start = vadd(muzzle, vmul(dir, 2));
    world.rockets.push({ pos: {...start}, vel: vmul(dir, 480), acc: 420, maxSpeed: 980, life: 3.8, yaw: Math.atan2(dir.y, dir.x), trail: [] });
    addShake(2.5); sfxRocketLaunch();
  }
  function fireGrenadeTo(mx, my){
    const dx = mx - player.pos.x, dy = my - player.pos.y; const dist = Math.hypot(dx,dy);
    const dir = Math.atan2(dy, dx); const speed = clamp(dist * 1.3, 380, 840);
    const vz0 = clamp(dist*0.55, 320, 720), g = 980;
    world.grenades.push({ pos: {x: player.pos.x, y: player.pos.y}, vel: {x: Math.cos(dir)*speed, y: Math.sin(dir)*speed}, z: 14, vz: vz0, g, life: 5, yaw: dir });
  }
  function fireFlashbangTo(mx,my){
    const dx = mx - player.pos.x, dy = my - player.pos.y; const dist = Math.hypot(dx,dy);
    const dir = Math.atan2(dy, dx);
    const vPlanar = 520;
    const t = Math.max(0.2, dist / vPlanar);
    const g = 980; const z0 = 14;
    const vz0 = 0.5 * g * t - (z0 / t);
    const vel = {x: Math.cos(dir)*vPlanar, y: Math.sin(dir)*vPlanar};
    world.flashbangs.push({ pos:{x:player.pos.x, y:player.pos.y}, vel, z:z0, vz:vz0, g, life:t+0.2, yaw:dir, tLand:t, elapsed:0, target:{x:mx,y:my} });
  }

  // 统一爆炸
  function explodeFiery(p, power=1.0){
    world.shockwaves.push({pos:{...p}, r: 12, maxR: 260*power, w: 10, life: 0.5*power, t:0,
      color:{o:'rgba(255,255,255,', i:'rgba(255,255,255,'}});
    const sparks = Math.floor(60*power);
    for(let i=0;i<sparks;i++){
      const ang = rand(0, TAU), spd = rand(180, 880)*power;
      const col = (Math.random()<0.5) ? 'rgba(255,220,130,' : 'rgba(255,180,90,';
      world.particles.push({ pos: {...p}, vel: {x: Math.cos(ang)*spd, y: Math.sin(ang)*spd}, life: rand(0.35,0.8), size: rand(2,4)*power, color: col, glow: true });
    }
    const shards = Math.floor(24*power);
    for(let i=0;i<shards;i++){
      const ang = rand(0,TAU), spd = rand(200, 760)*power;
      world.particles.push({pos:{...p}, vel:{x:Math.cos(ang)*spd, y:Math.sin(ang)*spd}, life: rand(0.5,1.1), size: rand(1,2), color:'rgba(200,220,240,', glow:false});
    }
    const smokes = Math.floor(46*power);
    for(let i=0;i<smokes;i++){
      const ang = rand(0,TAU), spd = rand(30, 160)*power;
      const base = Math.random()<0.6 ? 40 : 20;
      const c = `rgba(${base},${base+10},${base+20},`;
      world.particles.push({ pos:{...p}, vel:{x:Math.cos(ang)*spd, y:Math.sin(ang)*spd}, life: rand(0.9,1.8)*power, size: rand(6,12), color:c, glow:false });
    }
    addShake(9*power);
  }

  function distancePointRect(px,py,b){
    const dx = Math.max(b.x - px, 0, px - (b.x+b.w));
    const dy = Math.max(b.y - py, 0, py - (b.y+b.h));
    return Math.hypot(dx,dy);
  }
  function blastDamageBuildings(center, radius, base){
    for (let i=city.buildings.length-1;i>=0;i--){
      const b = city.buildings[i];
      const d = distancePointRect(center.x, center.y, b);
      if (d <= radius){
        const fall = 1 - d/radius;
        b.hp -= Math.max(0, base*fall);
        if (b.hp<=0) destroyBuilding(i);
      }
    }
  }
  function blastDamage(center, radius, base){
    for (const e of world.enemies){
      if (e.dead) continue;
      if (e.type==='heli') continue; // 直升机不受 AoE/E
      const d = Math.hypot(e.pos.x-center.x, e.pos.y-center.y);
      if (d<=radius){ const fall = 1 - d/radius; e.hp -= Math.max(1, base*fall); if (e.hp<=0) killEnemy(e); }
    }
  }
  function rocketBoom(p, direct=false){
    const pow = direct?1.0:0.9;
    explodeFiery(p, pow); sfxExplosionRocket();
    blastDamage(p, direct?120:100, direct?320:260);
    blastDamageBuildings(p, direct?150:130, direct?380:320);
  }
  function grenadeBoom(p){
    explodeFiery(p, 1.15); sfxExplosionGrenade();
    blastDamage(p, Math.floor(GRENADE_BLAST*1.5), 1200);
    blastDamageBuildings(p, Math.floor(GRENADE_BLAST*2.0), 900);
  }
  function bombletBoom(p){
    explodeFiery(p, 0.5); sfxExplosionBomblet();
    blastDamage(p, Math.floor(BOMBLET_BLAST), 700);
    blastDamageBuildings(p, Math.floor(BOMBLET_BLAST*1.4), 400);
  }
  function explodeGrenade(p){ grenadeBoom(p); const n = 10; for(let i=0;i<n;i++){ const ang = rand(0, TAU), spd = rand(200, 420); world.bomblets.push({ pos:{...p}, vel:{x:Math.cos(ang)*spd, y:Math.sin(ang)*spd}, life: rand(0.25, 0.5), fuse: rand(0.2,0.45) }); } }
  function explodeFlash(p){
    world.shockwaves.push({pos:{...p}, r: 8, maxR: 360, w: 30, life: 0.6, t:0,
      color:{o:'rgba(255,255,255,', i:'rgba(255,255,255,'}});
    for(let i=0;i<40;i++){ const ang = rand(0,TAU), spd=rand(120,360); world.particles.push({pos:{...p}, vel:{x:Math.cos(ang)*spd, y:Math.sin(ang)*spd}, life: rand(0.25,0.6), size: rand(2,3), color:'rgba(255,255,255,', glow:true}); }
    for (const e of world.enemies){
      if (e.dead) continue;
      if (e.type==='heli') continue;
      const d = Math.hypot(e.pos.x - p.x, e.pos.y - p.y);
      if (d<=FLASH_BLAST){ e.stun = Math.max(e.stun||0, 5.0); e.hp -= 1; if (e.hp<=0) killEnemy(e); }
    }
    addShake(8); flashWhite = Math.max(flashWhite, 0.9); sfxFlashBang();
  }
  function destroyBuilding(idx){
    const b = city.buildings[idx]; if (!b) return;
    const c = {x:b.x + b.w/2, y:b.y + b.h/2};
    for(let i=0;i<140;i++){
      const ang = Math.random()*TAU, spd = rand(40, 240);
      world.particles.push({pos:{...c}, vel:{x:Math.cos(ang)*spd, y:Math.sin(ang)*spd}, life:rand(1.2,2.4), size:rand(6,12), color:'rgba(140,150,160,', glow:false});
    }
    world.shockwaves.push({pos:{...c}, r:12, maxR:260, w:18, life:0.6, t:0, color:{o:'rgba(255,255,255,', i:'rgba(255,255,255,'}});
    addShake(12); sfxBuildingCollapse();
    city.buildings.splice(idx,1);
  }

  // ---------- Enemies ----------
  function addEnemy(type, x, y){
    const t = TYPES[type];
    const e = {
      type, pos:{x,y}, angle:0, hp:t.hp, speed:t.speed||0, r:t.r, dead:false,
      cannonT:rand(0,1), mgT:rand(0,0.5), autoT:rand(0,0.5), rifleT:rand(0,0.5),
      rocketT:rand(0, t.rocketCD||0.2), // 直升机火箭单发 CD
      hasThrown:false, blind:0, stun:0, aware:false,
      patrolOrigin:{x,y}, patrolGoal:randomPatrolGoal({x,y}, 220), patrolTimer:rand(2,5),
      rot:0, evadeT:0, evadeSign: (Math.random()<0.5?-1:1),
      // 新增：碉堡炮塔角、直升机连发装填
      turretAng: rand(0,TAU),
      rocketBurst: 0,
      rocketReload: 0
    };
    world.enemies.push(e); return e;
  }
  function randomPatrolGoal(o, radius){
    const ang = rand(0,TAU), d = rand(radius*0.3, radius);
    return {x:o.x + Math.cos(ang)*d, y:o.y + Math.sin(ang)*d};
  }
  function spawnEnemy(type){
    const spot = randomOpenSpot(TYPES[type].r+6);
    return addEnemy(type, spot.x, spot.y);
  }
  function killEnemy(e){ if (e.dead) return; e.dead=true; explodeFiery(e.pos, e.type==='infantry'?0.5:0.9); }
  function enemyFireBullet(e, speed, dmg, spread, tint='enemyMG', isShell=false){
    const aim = Math.atan2(player.pos.y - e.pos.y, player.pos.x - e.pos.x);
    const err = (e.blind>0? 0.8 : 0.2) + spread;
    const ang = aim + rand(-err, err)*0.2;
    const vel = {x: Math.cos(ang)*speed, y: Math.sin(ang)*speed};
    world.eBullets.push({pos:{...e.pos}, vel, life: isShell? 1.6 : 2, length: isShell?22:14, dmg, tint, shell:isShell});
  }
  function enemyThrowGrenade(e){
    const dx = player.pos.x - e.pos.x, dy = player.pos.y - e.pos.y; const dist = Math.hypot(dx,dy);
    const dir = Math.atan2(dy, dx); const speed = clamp(dist * 1.0, 320, 700); const vz0 = clamp(dist*0.5, 280, 600), g=980;
    world.eGrenades.push({ pos:{x:e.pos.x, y:e.pos.y}, vel:{x:Math.cos(dir)*speed, y:Math.sin(dir)*speed}, z:12, vz:vz0, g, life:4, yaw:dir });
    sfxEnemyGrenade();
  }
  function enemyCannon(e){ enemyFireBullet(e, 600, 35, 0.04, 'enemyCannon', true); sfxEnemyCannon(); addShake(2); }

  // 直升机火箭（单发→目标点爆 + 7 连发后装弹 2s）
  function enemyLaunchRocket(e){
    const target = {x: player.pos.x, y: player.pos.y}; // 开火瞬间的玩家位置
    const dir = vnorm(vsub(target, e.pos));
    const speed = 900;
    const vel = vmul(dir, speed);
    const dist = Math.hypot(target.x - e.pos.x, target.y - e.pos.y);
    const life = Math.min(2.0, dist / speed + 0.2);
    world.eRockets.push({pos:{...e.pos}, vel, target, speed, life, yaw:Math.atan2(vel.y,vel.x)});
    sfxEnemyRocket();
  }

  const DETECT = { heavy_tank: 520, light_tank: 480, bunker: 600, infantry: 420, heli: 720 };

  function updateEnemies(dt){
    for (const e of world.enemies){ if (e.dead) continue; if (e.blind>0) e.blind = Math.max(0, e.blind - dt); if (e.stun>0) e.stun = Math.max(0, e.stun - dt); }

    function heliEvasion(e){
      let minD = 1e9, threat = null;
      for (const r of world.rockets){
        const d = Math.hypot(r.pos.x - e.pos.x, r.pos.y - e.pos.y);
        if (d < minD) { minD=d; threat=r; }
      }
      if (!threat || minD>360) return;
      const rdir = vnorm(threat.vel);
      const toHeli = vnorm(vsub(e.pos, threat.pos));
      const closing = rdir.x*toHeli.x + rdir.y*toHeli.y;
      if (closing > 0.7){
        e.evadeT = 0.6; e.evadeSign = (Math.random()<0.5?-1:1);
      }
    }

    for (const e of world.enemies){
      if (e.dead) continue;

      if (e.type==='heli'){ e.rot = (e.rot + dt*16) % TAU; }

      const toP = vsub(player.pos, e.pos);
      const dist = vlen(toP);
      if (!e.aware && dist <= DETECT[e.type]) e.aware = true;
      if (e.aware && dist > DETECT[e.type]*1.8) e.aware = false;

      if (e.stun>0 && e.type!=='heli') { continue; }

      if (!e.aware){
        e.patrolTimer -= dt;
        const goal = e.patrolGoal;
        if (!goal || e.patrolTimer<=0 || Math.hypot(e.pos.x-goal.x, e.pos.y-goal.y)<8){
          e.patrolGoal = randomPatrolGoal(e.patrolOrigin, 220);
          e.patrolTimer = rand(2,5);
        }
      }

      const losOK = (e.type==='heli') ? true : hasLineOfSight(e.pos, player.pos);

      const dirAng = Math.atan2(toP.y, toP.x);
      let desired = 0, strafe = 0;
      if (e.aware){
        if (e.type==='heavy_tank') desired = dist>420?1: (dist<320?-1:0);
        else if (e.type==='light_tank') desired = dist>380?1:(dist<260?-1:0);
        else if (e.type==='infantry') desired = dist>300?1:(dist<180?-1:0);
        else if (e.type==='heli') { desired = dist>420?1:(dist<300?-1:0); strafe = 0.6 * (Math.random()<0.5?1:-1); }
        else if (e.type==='bunker') desired = dist>420?0.6:(dist<260?-0.3:0); // 碉堡也挪动
      } else {
        if (e.speed>0 && e.patrolGoal){
          const pg = e.patrolGoal;
          const ang = Math.atan2(pg.y - e.pos.y, pg.x - e.pos.x);
          e.angle = ang;
          const v = vnorm({x:Math.cos(ang), y:Math.sin(ang)});
          if (e.type==='heli') e.pos = vadd(e.pos, vmul(v, e.speed*0.6*dt));
          else e.pos = moveWithBuildingCollisions(e.pos, vmul(v, e.speed*0.6), e.r, dt);
        }
      }

      if (e.type==='heli'){
        heliEvasion(e);
        let vx = Math.cos(dirAng)*e.speed*desired, vy = Math.sin(dirAng)*e.speed*desired;
        if (e.evadeT>0){
          e.evadeT -= dt;
          const px = -Math.sin(dirAng)*e.speed*1.2*e.evadeSign, py = Math.cos(dirAng)*e.speed*1.2*e.evadeSign;
          vx += px; vy += py;
        } else {
          vx += -Math.sin(dirAng)*e.speed*strafe;
          vy +=  Math.cos(dirAng)*e.speed*strafe;
        }
        e.angle = dirAng;
        e.pos = vadd(e.pos, vmul({x:vx, y:vy}, dt));
      } else {
        // 除直升机外均按地面碰撞移动（含碉堡）
        const v = vnorm({x:Math.cos(dirAng),y:Math.sin(dirAng)});
        const vel = vmul(v, e.speed*desired);
        e.angle = dirAng;
        e.pos = moveWithBuildingCollisions(e.pos, vel, e.r, dt);
      }

      // 碉堡炮塔旋转（独立角）
      if (e.type==='bunker'){
        const want = e.aware ? Math.atan2(toP.y, toP.x) : (e.turretAng + TYPES.bunker.turretRate*dt);
        e.turretAng = angleLerp(e.turretAng, want, 0.15);
      }

      // 攻击
      if (e.aware && losOK){
        if (e.type==='heavy_tank'){
          e.cannonT -= dt; e.mgT -= dt;
          if (e.blind<=0 && dist<600 && e.cannonT<=0){ enemyCannon(e); e.cannonT = TYPES.heavy_tank.cannonCD + rand(0,0.6); }
          if (e.blind<=0 && dist<520 && e.mgT<=0){ enemyFireBullet(e, 900, 6, 0.05, 'enemyMG'); e.mgT = TYPES.heavy_tank.mgCD + rand(0,0.05); sfxEnemyMG(); }
        } else if (e.type==='light_tank'){
          e.autoT -= dt; e.mgT -= dt;
          if (e.blind<=0 && dist<520 && e.autoT<=0){ enemyFireBullet(e, 1100, 10, 0.06, 'enemyAuto'); e.autoT = TYPES.light_tank.autoCD; sfxEnemyAuto(); }
          if (e.blind<=0 && dist<500 && e.mgT<=0){ enemyFireBullet(e, 900, 6, 0.08, 'enemyMG'); e.mgT = TYPES.light_tank.mgCD; sfxEnemyMG(); }
        } else if (e.type==='bunker'){
          e.mgT -= dt; if (e.blind<=0 && e.mgT<=0 && dist<620){ enemyFireBullet(e, 950, 7, 0.07, 'enemyMG'); e.mgT = TYPES.bunker.mgCD; sfxEnemyMG(); }
        } else if (e.type==='infantry'){
          if (!e.hasThrown && dist<520 && e.blind<=0){ enemyThrowGrenade(e); e.hasThrown=true; }
          e.rifleT -= dt; if (e.blind<=0 && e.rifleT<=0 && dist<520){ enemyFireBullet(e, 1000, 8, 0.1, 'enemyRifle'); e.rifleT = TYPES.infantry.rifleCD + rand(0,0.3); sfxEnemyRifle(); }
        } else if (e.type==='heli'){
          if (e.rocketReload>0) { e.rocketReload = Math.max(0, e.rocketReload - dt); }
          e.rocketT -= dt;
          if (e.rocketReload<=0 && dist<780 && e.blind<=0 && e.rocketT<=0){
            enemyLaunchRocket(e); // 单发
            e.rocketBurst++;
            if (e.rocketBurst >= TYPES.heli.burst){
              e.rocketReload = TYPES.heli.reload; // 进入装弹
              e.rocketBurst = 0;
            }
            e.rocketT = TYPES.heli.rocketCD;
          }
        }
      }
    }
  }

  function updateEnemyBullets(dt){
    for (let i=world.eBullets.length-1;i>=0;i--){
      const b = world.eBullets[i]; b.life -= dt;
      b.pos = vadd(b.pos, vmul(b.vel, dt));
      const hitB = anyBuildingAtPoint(b.pos);
      if (hitB){
        if (b.shell){ explodeFiery(b.pos, 0.9); blastDamageBuildings(b.pos, 140, 220); }
        else { damageBuildingIndex(hitB.i, b.dmg); }
        world.eBullets.splice(i,1); continue;
      }
      if (Math.hypot(b.pos.x - player.pos.x, b.pos.y - player.pos.y) < player.radius+2){
        addShake(b.shell?2.0:1.2); if (b.shell){ explodeFiery(b.pos, 0.9); } world.eBullets.splice(i,1); continue;
      }
      if (b.life<=0 || b.pos.x< -20||b.pos.x>MAP_W+20||b.pos.y< -20||b.pos.y>MAP_H+20){
        if (b.shell){ explodeFiery(b.pos, 0.9); } world.eBullets.splice(i,1); continue;
      }
    }
  }
  function updateEnemyGrenades(dt){
    for (let i=world.eGrenades.length-1;i>=0;i--){
      const g = world.eGrenades[i];
      g.life -= dt;
      g.pos = vadd(g.pos, vmul(g.vel, dt));
      g.vz -= 980*dt; g.z += g.vz*dt; g.yaw = Math.atan2(g.vel.y,g.vel.x);
      if (g.z<=0 || g.life<=0){
        explodeFiery(g.pos, 0.18); // 视觉更小
        blastDamageBuildings(g.pos, ENEMY_GRENADE_R, 120);
        world.eGrenades.splice(i,1);
      }
    }
  }
  // 敌直升机火箭：忽略建筑，抵达 target 时爆炸
  function updateEnemyRockets(dt){
    for (let i=world.eRockets.length-1;i>=0;i--){
      const r = world.eRockets[i];
      r.life -= dt;
      const prev = {x:r.pos.x, y:r.pos.y};
      r.pos = vadd(r.pos, vmul(r.vel, dt));
      r.yaw = Math.atan2(r.vel.y, r.vel.x);
      // 是否越过目标点（投影判断）或接近阈值
      const toTargetPrev = vsub(r.target, prev);
      const toTargetNow  = vsub(r.target, r.pos);
      const passed = (toTargetPrev.x*r.vel.x + toTargetPrev.y*r.vel.y) >= 0 &&
                     (toTargetNow.x*r.vel.x  + toTargetNow.y*r.vel.y) <= 0;
      const near = Math.hypot(toTargetNow.x, toTargetNow.y) <= r.speed*dt*1.1;
      if (near || passed || r.life<=0){
        explodeFiery(r.target, 0.35);
        world.eRockets.splice(i,1);
        addShake(2);
        continue;
      }
      if (r.pos.x<-60||r.pos.x>MAP_W+60||r.pos.y<-60||r.pos.y>MAP_H+60){
        world.eRockets.splice(i,1);
      }
    }
  }

  // ---------- Buildings helpers ----------
  function anyBuildingAtPoint(p){
    for(let i=0;i<city.buildings.length;i++){ const b=city.buildings[i]; if (pointInRect(p.x,p.y,b)) return {i,b}; }
    return null;
  }
  function damageBuildingIndex(i, dmg){
    const b = city.buildings[i]; if (!b) return;
    b.hp -= Math.max(0, dmg);
    if (b.hp<=0) destroyBuilding(i);
  }

  // ---------- Movement ----------
  function collidesCircleBuildings(p, r){
    for (const b of city.buildings){ if (collidesCircleRect(p.x,p.y,r,b)) return true; }
    return false;
  }
  function moveWithBuildingCollisions(pos, vel, r, dt){
    let nx = pos.x + vel.x*dt, ny = pos.y;
    if (collidesCircleBuildings({x:nx,y:ny}, r)) nx = pos.x;
    ny = pos.y + vel.y*dt;
    if (collidesCircleBuildings({x:nx,y:ny}, r)) ny = pos.y;
    return {x: clamp(nx, 30, MAP_W-30), y: clamp(ny, 30, MAP_H-30)};
  }

  // ---------- Spawn ----------
  function generateUnits(){
    player.pos = randomOpenSpot(player.radius+10);
    cam.x = player.pos.x; cam.y = player.pos.y;

    for (let i=0;i<4;i++) spawnEnemy('bunker');
    for (let i=0;i<2;i++) spawnEnemy('heavy_tank');
    for (let i=0;i<2;i++) spawnEnemy('light_tank');
    for (let k=0;k<3;k++){ for (let i=0;i<5;i++){ const s = randomOpenSpot(14); addEnemy('infantry', s.x, s.y); } }
    for (let i=0;i<2;i++){ const s = randomOpenSpot(10); addEnemy('heli', s.x, s.y); }
  }
  generateUnits();

  // ---------- Update ----------
  let qCooldown = 0, flashWhite = 0;
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now; world.time += dt;

    // 从键盘与移动轮盘汇总移动向量
    let mv = vec2(0,0);
    if (keys.has('w')) mv.y -= 1;
    if (keys.has('s')) mv.y += 1;
    if (keys.has('a')) mv.x -= 1;
    if (keys.has('d')) mv.x += 1;
    if (touchMove.active){ mv = vadd(mv, touchMove.vec); }
    if (mv.x||mv.y){ mv = vnorm(mv); player.baseAngle = Math.atan2(mv.y, mv.x); }

    const speed = player.speed * (keys.has('shift') ? 1.35 : 1);
    player.vel = vmul(mv, speed);
    player.pos = moveWithBuildingCollisions(player.pos, player.vel, player.radius, dt);

    player.trackScroll += vlen(player.vel) * dt * 10;

    cam.x = clamp(player.pos.x, W/2, Math.max(W/2, MAP_W - W/2));
    cam.y = clamp(player.pos.y, H/2, Math.max(H/2, MAP_H - H/2));

    // 炮塔朝向：鼠标或普攻轮盘
    if (touchFire.active && vlen(touchFire.vec)>0.05){
      player.turretAngle = Math.atan2(touchFire.vec.y, touchFire.vec.x);
      mouse.left = true;
    } else {
      mouseWorld = screenToWorld(mouse);
      player.turretAngle = Math.atan2(mouseWorld.y - player.pos.y, mouseWorld.x - player.pos.x);
      if (!mouse.left && !touchFire.active) mouse.left = false;
    }

    fireGAU8(dt);

    if (rocketAmmo < rocketMagazine) {
      rocketReloadAcc += dt;
      if (rocketReloadAcc >= rocketReloadInterval) {
        const gain = Math.floor(rocketReloadAcc / rocketReloadInterval);
        rocketReloadAcc -= gain * rocketReloadInterval;
        rocketAmmo = Math.min(rocketMagazine, rocketAmmo + gain);
      }
    }
    if (mouse.right) { fireRocket(); mouse.right=false; }

    // 玩家子弹
    for (let i=world.bullets.length-1;i>=0;i--){
      const b=world.bullets[i];
      b.life -= dt; if (b.life<=0){ world.bullets.splice(i,1); continue; }
      b.pos = vadd(b.pos, vmul(b.vel, dt));
      const hb = anyBuildingAtPoint(b.pos); if (hb){ damageBuildingIndex(hb.i, b.dmg); world.bullets.splice(i,1); continue; }
      let hitEnemy = null;
      for (const e of world.enemies){ if (e.dead) continue; if (Math.hypot(b.pos.x - e.pos.x, b.pos.y - e.pos.y) < (e.r+3)){ hitEnemy = e; break; }}
      if (hitEnemy){
        hitEnemy.hp -= b.dmg; sfxHitMarker(); /* 去除命中震动 */ // addShake(0.08);
        for(let k=0;k<3;k++){ const ang=rand(0,TAU), sp=rand(120,260); world.particles.push({pos:{...b.pos}, vel:{x:Math.cos(ang)*sp,y:Math.sin(ang)*sp}, life:rand(0.08,0.22), size:1.5, color:'rgba(255,240,180,', glow:true}); }
        if (hitEnemy.hp<=0) killEnemy(hitEnemy);
        world.bullets.splice(i,1); continue;
      }
      if (b.pos.x<-50||b.pos.x>MAP_W+50||b.pos.y<-50||b.pos.y>MAP_H+50){ world.bullets.splice(i,1); }
    }

    // 玩家 RPG
    for (let i=world.rockets.length-1;i>=0;i--){ const r=world.rockets[i];
      const hitB = anyBuildingAtPoint(r.pos);
      if (hitB){ rocketBoom(r.pos, false); world.rockets.splice(i,1); continue; }
      let hit=false; let hitPos=null;
      for (const e of world.enemies){
        if (e.dead) continue;
        if (Math.hypot(r.pos.x - e.pos.x, r.pos.y - e.pos.y) < (e.r+6)){
          if (e.type!=='heli'){ killEnemy(e); hit=true; hitPos={...r.pos}; break; }
          else { hit=true; hitPos={...r.pos}; break; }
        }
      }
      r.life-=dt; const v=vlen(r.vel); const newV=clamp(v+r.acc*dt,0,r.maxSpeed); r.vel=vmul(vnorm(r.vel),newV); r.pos=vadd(r.pos, vmul(r.vel, dt)); r.yaw=Math.atan2(r.vel.y,r.vel.x); r.trail.push({x:r.pos.x,y:r.pos.y,life:0.25}); if (r.trail.length>30) r.trail.shift();
      if (hit){ rocketBoom(hitPos, false); world.rockets.splice(i,1); continue; }
      if (r.life<=0){ rocketBoom(r.pos, false); world.rockets.splice(i,1); continue; }
      if (r.pos.x<0||r.pos.x>MAP_W||r.pos.y<0||r.pos.y>MAP_H){ rocketBoom(r.pos, false); world.rockets.splice(i,1);}
    }

    // Q/E 抛射
    for (let i=world.grenades.length-1;i>=0;i--){ const g=world.grenades[i]; g.life-=dt; if (g.life<=0){ explodeGrenade(g.pos); world.grenades.splice(i,1); continue; } g.pos=vadd(g.pos, vmul(g.vel, dt)); g.vz-=980*dt; g.z+=g.vz*dt; g.yaw=Math.atan2(g.vel.y,g.vel.x); if (g.z<=0){ explodeGrenade(g.pos); world.grenades.splice(i,1);} }
    for (let i=world.flashbangs.length-1;i>=0;i--){ const f=world.flashbangs[i]; f.elapsed += dt; f.life-=dt; f.pos=vadd(f.pos, vmul(f.vel, dt)); f.vz-=980*dt; f.z+=f.vz*dt; f.yaw=Math.atan2(f.vel.y, f.vel.x); if (f.elapsed>=f.tLand){ f.pos.x = f.target.x; f.pos.y = f.target.y; explodeFlash(f.pos); world.flashbangs.splice(i,1); continue; } if (f.life<=0){ explodeFlash(f.pos); world.flashbangs.splice(i,1); continue; } }

    for (let i=world.bomblets.length-1;i>=0;i--){ const b=world.bomblets[i]; b.life-=dt; b.fuse-=dt; if (b.life<=0){ world.bomblets.splice(i,1); continue; } b.pos=vadd(b.pos, vmul(b.vel, dt)); b.vel=vmul(b.vel, 0.992);
      const hb = anyBuildingAtPoint(b.pos); if (hb){ bombletBoom(b.pos); world.bomblets.splice(i,1); continue; }
      if (b.fuse<=0){ bombletBoom(b.pos); world.bomblets.splice(i,1);}
    }

    // 敌人
    updateEnemies(dt); updateEnemyBullets(dt); updateEnemyGrenades(dt); updateEnemyRockets(dt);

    // Shockwaves / particles
    for (let i=world.shockwaves.length-1;i>=0;i--){ const s=world.shockwaves[i]; s.t+=dt; s.r = lerp(12, s.maxR, s.t/s.life); s.w = lerp(10, 40, s.t/s.life); if (s.t>=s.life) world.shockwaves.splice(i,1); }
    for (let i=world.particles.length-1;i>=0;i--){ const p=world.particles[i]; p.life-=dt; if (p.life<=0){ world.particles.splice(i,1); continue; } p.vel.x*=0.985; p.vel.y*=0.985; p.pos=vadd(p.pos, vmul(p.vel, dt)); }

    // HUD
    shake *= 0.92; if (shake<0.01) shake=0; flashWhite *= 0.88;
    updateRocketHUD();
    if (qCooldown>0) qCooldown = Math.max(0, qCooldown - dt);
    const qEl=document.getElementById('qCooldown'); if (qEl) qEl.textContent = qCooldown>0 ? (qCooldown.toFixed(1)+'s') : '就绪';

    render();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ---------- 自测 ----------
  function assert(name, cond){ if (!cond) { console.error('[TEST FAIL]', name); } else { console.log('[TEST OK]', name); } }
  (function selfTests(){
    const inBuilding = city.buildings.some(b => pointInRect(player.pos.x,player.pos.y,b));
    assert('spawn on open spot (player)', !inBuilding);
    const enemyInBuilding = world.enemies.some(e => city.buildings.some(b => collidesCircleRect(e.pos.x,e.pos.y,e.r,b)));
    assert('spawn on open spot (enemies)', !enemyInBuilding);
    const overlapRoad = city.buildings.some(b => city.roads.some(r => rectsOverlap(b,r,1)));
    assert('buildings not overlapping roads', !overlapRoad);
    assert('grenadeRange ≈ 533', grenadeRange>=530 && grenadeRange<=536);
    assert('GRENADE_BLAST ≈ 53', GRENADE_BLAST>=52 && GRENADE_BLAST<=54);
    assert('FLASH_BLAST = 80', FLASH_BLAST===80);
    assert('enemy grenade radius = 24', ENEMY_GRENADE_R===24);
    const heli = world.enemies.find(e=>e.type==='heli' && !e.dead);
    if (heli){
      heli.aware = true;
      heli.rocketReload = 0; heli.rocketT = 0; heli.rocketBurst = 0;
      let fired=0;
      for (let i=0;i<100;i++){ updateEnemies(0.11); if (world.eRockets.length>fired){ fired=world.eRockets.length; } if (heli.rocketReload>0){ break; } }
      assert('heli bursts then reloads', heli.rocketReload>0);
    } else { console.warn('[TEST SKIP] no heli spawned'); }
    assert('audioInited default false', audioInited===false);
    /* 新增：确保触控检测初始化完毕 */
    assert('isTouch is boolean', typeof isTouch === 'boolean');
  })();

  // ---------- Render ----------
  function renderBackground(){
    const grd = ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.1, W/2,H/2, Math.hypot(W,H)*0.7);
    grd.addColorStop(0,'#0d1117'); grd.addColorStop(1,'#0b0d12');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    ctx.save(); ctx.translate(Math.floor(W/2 - cam.x), Math.floor(H/2 - cam.y));

    // Roads
    for (const r of city.roads){
      const g=ctx.createLinearGradient(r.x, r.y, r.x+r.w, r.y+r.h);
      g.addColorStop(0,'#18202b'); g.addColorStop(1,'#1b2330');
      ctx.fillStyle=g; ctx.fillRect(r.x, r.y, r.w, r.h);
      ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=2; ctx.strokeRect(r.x, r.y, r.w, r.h);
      ctx.save(); ctx.strokeStyle='rgba(220,230,240,0.14)'; ctx.setLineDash([16,16]); ctx.lineWidth=2;
      if (r.w>r.h){ const y=r.y+r.h/2; ctx.beginPath(); ctx.moveTo(r.x, y); ctx.lineTo(r.x+r.w, y); ctx.stroke(); }
      else { const x=r.x+r.w/2; ctx.beginPath(); ctx.moveTo(x, r.y); ctx.lineTo(x, r.y+r.h); ctx.stroke(); }
      ctx.restore();
    }

    // Buildings（伪3D体块）
    for (const b of city.buildings){
      const elev = (b.elev||10);
      const dx = Math.floor(elev*0.35), dy = Math.floor(elev*0.5);

      ctx.fillStyle='rgba(0,0,0,0.35)';
      ctx.beginPath();
      ctx.moveTo(b.x+2, b.y+b.h+2);
      ctx.lineTo(b.x+dx+2, b.y+b.h+dy+2);
      ctx.lineTo(b.x+b.w+dx+2, b.y+b.h+dy+2);
      ctx.lineTo(b.x+b.w+2, b.y+b.h+2);
      ctx.closePath(); ctx.fill();

      let roofA='#2f3946', roofB='#2b3440', side='#202831';
      if (b.type==='industrial'){ roofA='#3b434c'; roofB='#2a3036'; side='#1f262c'; }
      if (b.type==='skyscraper'){ roofA='#3d4d5a'; roofB='#27323a'; side='#202730'; }
      if (b.type==='office'){ roofA='#2b3743'; roofB='#23303b'; side='#1d242b'; }
      if (b.type==='mall'){ roofA='#33404d'; roofB='#29333c'; side='#20262d'; }
      if (b.type==='ruin'){ roofA='#2a3139'; roofB='#23292f'; side='#151a1f'; }

      const rg = ctx.createLinearGradient(b.x, b.y, b.x+b.w, b.y+b.h);
      rg.addColorStop(0, roofA); rg.addColorStop(1, roofB);
      ctx.fillStyle = rg; ctx.fillRect(b.x, b.y, b.w, b.h);

      ctx.fillStyle = side;
      ctx.beginPath();
      ctx.moveTo(b.x+b.w, b.y);
      ctx.lineTo(b.x+b.w+dx, b.y+dy);
      ctx.lineTo(b.x+b.w+dx, b.y+b.h+dy);
      ctx.lineTo(b.x+b.w, b.y+b.h);
      ctx.closePath(); ctx.fill();

      ctx.beginPath();
      ctx.moveTo(b.x, b.y+b.h);
      ctx.lineTo(b.x+dx, b.y+b.h+dy);
      ctx.lineTo(b.x+b.w+dx, b.y+b.h+dy);
      ctx.lineTo(b.x+b.w, b.y+b.h);
      ctx.closePath(); ctx.fill();

      if (b.type==='residential' || b.type==='office'){
        ctx.fillStyle='rgba(255,255,255,0.07)';
        for(let x=b.x+6;x<b.x+b.w-6;x+=10){ for(let y=b.y+6;y<b.y+b.h-6;y+=10){ ctx.fillRect(x,y,2,2); }}
      }
      if (b.type==='industrial'){
        ctx.fillStyle='#21272d'; for(let i=0;i<3;i++){ ctx.fillRect(b.x+6+i*18,b.y+6,b.w-12,4); }
        ctx.fillStyle='#1b2127'; for(let i=0;i<2;i++){ ctx.fillRect(b.x+6,b.y+12+i*14,12,b.h-24); }
      }
      if (b.type==='skyscraper'){
        ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
        for(let x=b.x+6;x<b.x+b.w-6;x+=10){ ctx.beginPath(); ctx.moveTo(x,b.y+4); ctx.lineTo(x,b.y+b.h-4); ctx.stroke(); }
      }
      if (b.type==='mall'){
        ctx.fillStyle='#222a32'; ctx.fillRect(b.x+6,b.y+6,b.w-12,6); ctx.fillRect(b.x+6,b.y+b.h-12,b.w-12,6);
      }
      if (b.type==='ruin'){
        ctx.fillStyle='#1b2127'; for(let i=0;i<6;i++){ const rx=randInt(b.x,b.x+b.w-6), ry=randInt(b.y,b.y+b.h-6); ctx.fillRect(rx,ry,randInt(4,8),randInt(3,7)); }
      }

      ctx.strokeStyle='rgba(255,255,255,0.10)'; ctx.lineWidth=1; ctx.strokeRect(b.x,b.y,b.w,b.h);
    }

    ctx.restore();
  }

  function drawPlayerTank(){
    const x = player.pos.x, y = player.pos.y;
    ctx.save(); ctx.translate(x,y); ctx.rotate(player.baseAngle); ctx.scale(SCALE,SCALE);
    ctx.globalAlpha = 0.35; ctx.filter='blur(6px)'; roundedRect(-36, -22, 72, 44, 14, '#000'); ctx.filter='none'; ctx.globalAlpha = 1;
    const treadStep = 6; const off = player.trackScroll % treadStep;
    roundedRect(-38,-22, 76,12, 4, '#1c2330'); roundedRect(-38,10, 76,12, 4, '#1c2330');
    ctx.save(); ctx.beginPath(); roundPath(-38,-22,76,12,4); ctx.clip(); ctx.fillStyle='#2a3443'; for(let tx=-44+off; tx<44; tx+=treadStep){ ctx.fillRect(tx,-22,3,12); } ctx.restore();
    ctx.save(); ctx.beginPath(); roundPath(-38,10,76,12,4); ctx.clip(); ctx.fillStyle='#2a3443'; for(let tx=-44+off; tx<44; tx+=treadStep){ ctx.fillRect(tx,10,3,12); } ctx.restore();
    roundedRect(-32,-18, 64,36, 10, '#2b3543'); strokeRoundedRect(-32,-18,64,36,10,'rgba(255,255,255,.07)');
    ctx.restore();
    ctx.save(); ctx.translate(x,y); ctx.rotate(player.turretAngle); ctx.scale(SCALE,SCALE);
    roundedRect(-10,-12, 30,24, 10, '#374355'); strokeRoundedRect(-10,-12,30,24,10,'rgba(255,255,255,.07)');
    roundedRect(18,-4, 28,8, 4, '#8d9aab');
    for(let i=0;i<6;i++){ const yy=-6 + i*2.4; roundedRect(34, yy, 10,1.2, 0.6, '#b7c2d0'); }
    if (mouse.left && player.spin>0.08) { const glow = Math.max(0, player.spin*0.6); circle(48,0, 4+4*glow, `rgba(255,220,120,${0.35+0.35*glow})`); }
    ctx.restore();
  }

  function drawBullets(){ ctx.lineCap='round'; for (const b of world.bullets){ const dir = Math.atan2(b.vel.y, b.vel.x); const tail = {x: b.pos.x - Math.cos(dir)*b.length, y: b.pos.y - Math.sin(dir)*b.length}; const grad = ctx.createLinearGradient(tail.x, tail.y, b.pos.x, b.pos.y); grad.addColorStop(0, 'rgba(255,255,200,0)'); grad.addColorStop(1, 'rgba(255,230,120,0.95)'); ctx.strokeStyle = grad; ctx.lineWidth = 2.2; ctx.beginPath(); ctx.moveTo(tail.x, tail.y); ctx.lineTo(b.pos.x, b.pos.y); ctx.stroke(); circle(b.pos.x, b.pos.y, 1.2, 'rgba(255,255,180,0.95)'); } }
  function drawEnemyBullets(){ for (const b of world.eBullets){ const dir = Math.atan2(b.vel.y,b.vel.x); const tail = {x:b.pos.x - Math.cos(dir)*b.length, y:b.pos.y - Math.sin(dir)*b.length}; ctx.strokeStyle = (b.tint==='enemyCannon')?'rgba(255,180,150,0.9)':'rgba(255,180,120,0.8)'; ctx.lineWidth = (b.tint==='enemyCannon')?3:1.8; ctx.beginPath(); ctx.moveTo(tail.x, tail.y); ctx.lineTo(b.pos.x, b.pos.y); ctx.stroke(); } }
  function drawRockets(){ for (const r of world.rockets){ ctx.globalAlpha = 0.9; for (const t of r.trail){ t.life -= 0.016; const a = clamp(t.life/0.25, 0,1); circle(t.x, t.y, 3*a+1, `rgba(255,240,180,${0.6*a})`); } ctx.globalAlpha = 1; ctx.save(); ctx.translate(r.pos.x, r.pos.y); ctx.rotate(r.yaw); roundedRect(-12,-3, 24,6, 2, '#a2adba'); for (let i=0;i<4;i++) circle(-14 - i*3, 0, 4 - i, `rgba(255,210,120,${0.65 - i*0.14})`); ctx.restore(); } }
  function drawEnemyRockets(){ for (const r of world.eRockets){ ctx.save(); ctx.translate(r.pos.x, r.pos.y); ctx.rotate(r.yaw); roundedRect(-10,-2.5, 20,5, 2, '#b99b89'); circle(-8,0,3,'rgba(255,220,120,0.7)'); ctx.restore(); } }
  function drawGrenades(){ for (const g of world.grenades){ ctx.globalAlpha = 0.25; ctx.filter='blur(3px)'; circle(g.pos.x, g.pos.y, 8, '#000'); ctx.filter='none'; ctx.globalAlpha=1; ctx.save(); ctx.translate(g.pos.x, g.pos.y - g.z*0.7); ctx.rotate(g.yaw); roundedRect(-16,-6, 32,12, 6, '#3a4c5f'); ctx.restore(); } for (const f of world.flashbangs){ ctx.save(); ctx.translate(f.pos.x, f.pos.y - f.z*0.7); ctx.rotate(f.yaw); roundedRect(-8,-5,16,10,4,'#e6e8ea'); strokeRoundedRect(-8,-5,16,10,4,'rgba(0,0,0,.15)'); ctx.restore(); } for (const b of world.bomblets){ circle(b.pos.x, b.pos.y, 3, '#9bbcff'); } }
  function drawEnemies(){
    for (const e of world.enemies){ if (e.dead) continue; ctx.save(); ctx.translate(e.pos.x, e.pos.y); ctx.rotate(e.angle); ctx.scale(SCALE,SCALE);
      if (e.type==='heavy_tank' || e.type==='light_tank'){
        const body = e.type==='heavy_tank' ? '#3a454f' : '#465664';
        const turret = e.type==='heavy_tank'? '#2e3944' : '#35414d';
        roundedRect(-26,-18, 52,10, 4, '#232a33'); roundedRect(-26,8, 52,10, 4, '#232a33');
        roundedRect(-24,-16, 48,32, 8, body); strokeRoundedRect(-24,-16,48,32,8,'rgba(255,255,255,.06)');
        roundedRect(-8,-10, 26,20, 8, turret); roundedRect(18,-2, 20,4, 2, '#929fb0');
      }
      else if (e.type==='bunker'){
        // 基座
        ctx.save();
        ctx.globalAlpha=0.35; ctx.filter='blur(4px)'; roundedRect(-28,-22,56,44,12,'#000'); ctx.filter='none'; ctx.globalAlpha=1;
        roundedRect(-28,-18,56,36,10,'#2a2f36'); // 厚混凝土座
        strokeRoundedRect(-28,-18,56,36,10,'rgba(255,255,255,.06)');
        ctx.restore();
        // 旋转炮塔（独立角）
        ctx.save();
        ctx.rotate((e.turretAng||0) - e.angle); // 抵消底座旋转，只按炮塔角指向玩家
        roundedRect(-14,-10,28,20,8,'#1e242b'); // 炮塔舱
        strokeRoundedRect(-14,-10,28,20,8,'rgba(255,255,255,.08)');
        roundedRect(10,-2, 24,4, 2, '#a5b1be'); // 炮口
        ctx.restore();
      }
      else if (e.type==='infantry'){
        circle(0,-6,3,'#d9d7ce'); roundedRect(-4,-4,8,10,3,'#5b6c7a'); roundedRect(2,-2,10,3,2,'#9aa7b8');
      }
      else if (e.type==='heli'){
        // 阿帕奇风格 + 三叶桨
        ctx.save();
        ctx.globalAlpha=0.35; ctx.filter='blur(4px)'; roundedRect(-22,-12,44,24,9,'#000'); ctx.filter='none'; ctx.globalAlpha=1;
        roundedRect(-20,-10,40,20,8,'#36434f'); strokeRoundedRect(-20,-10,40,20,8,'rgba(255,255,255,0.06)');
        roundedRect(0,-8,14,16,6,'#1e2a34'); strokeRoundedRect(0,-8,14,16,6,'rgba(255,255,255,0.08)');
        roundedRect(6,-6,8,12,4,'#18222b');
        roundedRect(-22,-4,16,8,3,'#2b3642'); roundedRect(6,-4,16,8,3,'#2b3642');
        for(let i=0;i<3;i++){ circle(-16 + i*5,0,1.5,'#b0bac7'); circle(12 - i*5,0,1.5,'#b0bac7'); }
        roundedRect(-32,-2,12,4,2,'#2e3944');
        ctx.save(); ctx.translate(-34,0); ctx.rotate(-e.rot*1.6);
        roundedRect(-4,-1,8,2,1,'#c6d2df'); ctx.restore();
        ctx.save(); ctx.rotate(e.rot);
        for (let k=0;k<3;k++){ ctx.save(); ctx.rotate(k*TAU/3); roundedRect(-34,-1.7,68,3.4,1.7,'#c7d5e2'); ctx.restore(); }
        ctx.restore();
        ctx.restore();
      }
      ctx.restore();
      // HP条
      ctx.save(); ctx.translate(e.pos.x, e.pos.y); const hpPct = clamp(e.hp / TYPES[e.type].hp, 0, 1);
      const barW = Math.max(36*SCALE, e.r*2), barH = 4, by = -e.r - 16;
      roundedRect(-barW/2, by, barW, barH, 2, 'rgba(255,255,255,.12)');
      ctx.beginPath(); ctx.rect(-barW/2, by, barW*hpPct, barH); ctx.fillStyle = `hsl(${100*hpPct}, 80%, 60%)`; ctx.fill(); ctx.restore();
    }
  }
  function drawShockwaves(){ for (const s of world.shockwaves){ const a = 1 - (s.t / s.life); ctx.save(); ctx.filter = 'blur(3px)'; ctx.globalCompositeOperation = 'screen'; ctx.strokeStyle = `${s.color ? s.color.o : 'rgba(255,255,255,'}${0.35*a})`; ctx.lineWidth = s.w; ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, s.r, 0, TAU); ctx.stroke(); ctx.globalCompositeOperation = 'lighter'; ctx.lineWidth = 2; ctx.strokeStyle = `${s.color ? s.color.i : 'rgba(255,255,255,'}${0.25*a})`; ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, s.r, 0, TAU); ctx.stroke(); ctx.restore(); } }
  function drawReticle(){ const x=mouse.x, y=mouse.y; ctx.save(); ctx.strokeStyle = 'rgba(255,255,255,.45)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(x,y, 10, 0, TAU); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-16,y); ctx.lineTo(x-6,y); ctx.moveTo(x+6,y); ctx.lineTo(x+16,y); ctx.moveTo(x,y-16); ctx.lineTo(x,y-6); ctx.moveTo(x,y+6); ctx.lineTo(x,y+16); ctx.stroke(); ctx.restore(); }
  function drawGrenadeIndicator(){ if (!grenadeTargeting && !eTargeting && !touchQ.preview && !touchE.preview) return; const isQ = grenadeTargeting || touchQ.preview; const rawWorld = (touchQ.preview||touchE.preview) ? touchPreviewWorld : mouseWorld; const tWorld = clampToRange(rawWorld, player.pos, grenadeRange); const t = worldToScreen(tWorld); const inner = isQ ? GRENADE_BLAST : FLASH_BLAST; ctx.save(); ctx.setLineDash([8, 10]); ctx.lineDashOffset = -world.time*60; ctx.strokeStyle = isQ ? 'rgba(120,190,255,.9)' : 'rgba(255,255,255,.85)'; ctx.lineWidth=2; const pS = worldToScreen(player.pos); ctx.beginPath(); ctx.arc(pS.x, pS.y, grenadeRange, 0, TAU); ctx.stroke(); ctx.setLineDash([]); const outOfRange = (Math.hypot(rawWorld.x - tWorld.x, rawWorld.y - tWorld.y)>1e-3); ctx.strokeStyle = outOfRange ? 'rgba(255,120,120,0.95)' : (isQ?'rgba(110,200,255,.95)':'rgba(255,255,255,.95)'); ctx.lineWidth=2; ctx.beginPath(); ctx.arc(t.x, t.y, inner, 0, TAU); ctx.stroke(); ctx.restore(); }
  function drawParticles(){ for (const p of world.particles){ const a = clamp(p.life / 1.2, 0, 1); circle(p.pos.x, p.pos.y, p.size, `${p.color}${0.35 + 0.65*a})`); } }
  function render(){
    ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,W,H);
    renderBackground();
    const sx = (Math.random()*2-1) * shake, sy = (Math.random()*2-1) * shake;
    ctx.save(); ctx.translate(Math.floor(W/2 - cam.x) + sx, Math.floor(H/2 - cam.y) + sy);
    drawBullets(); drawEnemyBullets(); drawRockets(); drawEnemyRockets(); drawGrenades(); drawParticles(); drawShockwaves(); drawEnemies(); drawPlayerTank();
    ctx.restore();
    if (flashWhite>0){ ctx.globalAlpha = Math.min(1, flashWhite); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,W,H); ctx.globalAlpha=1; }
    drawReticle(); drawGrenadeIndicator(); drawMinimap();
  }

  // ---------- HUD ----------
  function updateRocketHUD(){
    document.getElementById('rocketCount').textContent = rocketAmmo;
    const slots = document.getElementById('rocketSlots');
    if (!slots.dataset.init){ slots.dataset.init='1'; for (let i=0;i<rocketMagazine;i++){ const s=document.createElement('div'); s.className='ammoSlot'; const f=document.createElement('div'); f.className='ammoFill'; f.style.height='0%'; s.appendChild(f); slots.appendChild(s);} }
    const fills = [...slots.querySelectorAll('.ammoFill')];
    for (let i=0;i<rocketMagazine;i++){
      if (i < rocketAmmo) { fills[i].style.height = '100%'; fills[i].style.background = 'hsl(200,80%,65%)'; }
      else if (i===rocketAmmo) { const pct = clamp((rocketReloadAcc/rocketReloadInterval), 0, 1); fills[i].style.height = (pct*100)+'%'; const hue = 10 + pct*190; fills[i].style.background = `hsl(${hue}, 80%, 60%)`; }
      else { fills[i].style.height='0%'; fills[i].style.background = 'hsl(0,0%,30%)'; }
    }
  }
  updateRocketHUD();

  // ---------- Minimap ----------
  function drawMinimap(){
    const mm = document.getElementById('minimap'); if (!mm) return; const mctx = mm.getContext('2d'); const w=mm.width, h=mm.height; mctx.clearRect(0,0,w,h);
    mctx.fillStyle = 'rgba(20,26,36,0.95)'; mctx.fillRect(0,0,w,h);
    const sx = w / MAP_W, sy = h / MAP_H;
    mctx.fillStyle = '#263241';
    for (const r of city.roads){ mctx.fillRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
    mctx.fillStyle = '#344150';
    for (const b of city.buildings){ mctx.fillRect(b.x*sx, b.y*sy, b.w*sx, b.h*sy); }
    for (const e of world.enemies){
      if (e.dead) continue;
      const ex=(e.pos.x*sx), ey=(e.pos.y*sy);
      mctx.fillStyle = (e.type==='infantry')? '#ffab7a' : (e.type==='heli' ? '#ffe28a' : '#ff6e6e');
      mctx.fillRect(ex-2, ey-2, 4,4);
    }
    const px = player.pos.x*sx, py = player.pos.y*sy; mctx.fillStyle='#9bd5ff'; mctx.beginPath(); mctx.arc(px, py, 3, 0, TAU); mctx.fill();
    const vx = ((cam.x - W/2)*sx), vy=((cam.y - H/2)*sy), vw=(W*sx), vh=(H*sy); mctx.strokeStyle='rgba(255,255,255,0.6)'; mctx.strokeRect(vx,vy,Math.max(2,vw),Math.max(2,vh));
  }

  // ---------- Primitives ----------
  function roundPath(x,y,w,h,r){
    const rr=Math.min(r,Math.abs(w)/2,Math.abs(h)/2);
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
  }
  function roundedRect(x,y,w,h,r,fill){ ctx.beginPath(); roundPath(x,y,w,h,r); ctx.fillStyle=fill; ctx.fill(); }
  function strokeRoundedRect(x,y,w,h,r,stroke){ ctx.beginPath(); roundPath(x,y,w,h,r); ctx.strokeStyle=stroke; ctx.stroke(); }
  function circle(x,y,r,fill){ ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fillStyle=fill; ctx.fill(); }
  function clampToRange(p, origin, range){ const dx = p.x - origin.x, dy = p.y - origin.y; const d = Math.hypot(dx,dy); if (d<=range) return p; const t = range/d; return {x: origin.x + dx*t, y: origin.y + dy*t}; }

  // ---------- Audio ----------
  function initAudio(){ if (audioInited) return; audioInited=true; AC = new (window.AudioContext||window.webkitAudioContext)(); const len = AC.sampleRate*2; const buf = AC.createBuffer(1, len, AC.sampleRate); const ch = buf.getChannelData(0); for (let i=0;i<len;i++) ch[i] = Math.random()*2-1; noiseBuf=buf; }
  function env(node, a, d, gain=1){ const g=AC.createGain(); node.connect(g); g.connect(AC.destination); const now=AC.currentTime; g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(gain, now+a); g.gain.exponentialRampToValueAtTime(0.0001, now+a+d); return g; }
  function sfxGAU(rate=1){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const hp=AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1600+rate*1200; src.connect(hp); env(hp, 0.004, 0.04, 0.12); src.start(); }
  function sfxGrenadeThrow(){ if(!AC) return; const o=AC.createOscillator(); o.type='sine'; o.frequency.value=440; env(o,0.01,0.1,0.12); o.start(); o.stop(AC.currentTime+0.2); }
  function sfxRocketLaunch(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const bp=AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=400; bp.Q.value=0.7; src.connect(bp); env(bp,0.02,0.5,0.3); src.start(); }
  function sfxExplosionGrenade(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const lp=AC.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=380; src.connect(lp); env(lp,0.005,0.9,0.7); src.start(); }
  function sfxExplosionRocket(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const lp=AC.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=520; src.connect(lp); env(lp,0.008,1.1,0.85); src.start(); }
  function sfxExplosionBomblet(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const hp=AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200; src.connect(hp); env(hp,0.003,0.2,0.2); src.start(); }
  function sfxFlashThrow(){ if(!AC) return; const o=AC.createOscillator(); o.type='square'; o.frequency.value=520; env(o,0.01,0.08,0.12); o.start(); o.stop(AC.currentTime+0.18); }
  function sfxFlashBang(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const hp=AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=800; src.connect(hp); env(hp,0.002,0.6,0.9); src.start(); }
  function sfxEnemyMG(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const hp=AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1400; src.connect(hp); env(hp,0.002,0.05,0.05); src.start(); }
  function sfxEnemyAuto(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const hp=AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1000; src.connect(hp); env(hp,0.002,0.06,0.06); src.start(); }
  function sfxEnemyCannon(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const lp=AC.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=420; src.connect(lp); env(lp,0.01,0.6,0.12); src.start(); }
  function sfxEnemyRifle(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const hp=AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1800; src.connect(hp); env(hp,0.001,0.04,0.04); src.start(); }
  function sfxEnemyGrenade(){ if(!AC) return; const o=AC.createOscillator(); o.type='sine'; o.frequency.value=380; env(o,0.01,0.09,0.06); o.start(); o.stop(AC.currentTime+0.18); }
  function sfxBuildingCollapse(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const lp=AC.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=260; src.connect(lp); env(lp,0.02,1.6,1.0); src.start(); }
  function sfxEnemyRocket(){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const bp=AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=600; bp.Q.value=0.8; src.connect(bp); env(bp,0.02,0.4,0.22); src.start(); }
  function sfxHitMarker(){ if(!AC) return; const o=AC.createOscillator(); const g=AC.createGain(); o.type='triangle'; o.frequency.value=1200; g.gain.value=0.0001; o.connect(g); g.connect(AC.destination); const now=AC.currentTime; g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.2, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.12); o.start(); o.stop(now+0.14); }

  // ---------- 移动端轮盘 ----------
  function positionTouchUI(){
    if (!isTouch) return;
    const ui = document.getElementById('touchUI');
    if (!ui) return;
    // 左下移动
    if (touchMove.el){ touchMove.el.style.left = '24px'; touchMove.el.style.bottom = '24px'; }
    // 右侧三轮盘
    if (touchFire.el){ touchFire.el.style.right = '24px'; touchFire.el.style.bottom = '24px'; }
    if (touchQ.el){ touchQ.el.style.right = '184px'; touchQ.el.style.bottom = '144px'; }
    if (touchE.el){ touchE.el.style.right = '24px'; touchE.el.style.bottom = '184px'; }
  }

  function makeJoy(label){
    const el = document.createElement('div'); el.className='joy';
    const knob = document.createElement('div'); knob.className='knob';
    const text = document.createElement('div'); text.className='label'; text.textContent=label;
    el.appendChild(knob); el.appendChild(text);
    return {el, knob};
  }
  function bindJoy(joy, state, onRelease){
    const maxR = 60;
    const center = {x:0,y:0};
    function setKnob(dx,dy){
      const len = Math.hypot(dx,dy);
      const k = len>maxR ? maxR/len : 1;
      const x = dx*k, y = dy*k;
      joy.knob.style.transform = `translate(${x}px,${y}px)`;
      const v = len>0 ? {x:dx/maxR, y:dy/maxR} : {x:0,y:0};
      state.vec = {x: clamp(v.x,-1,1), y: clamp(v.y,-1,1)};
    }
    function reset(){
      state.active=false; state.vec={x:0,y:0};
      joy.knob.style.transform = `translate(0px,0px)`;
      if (onRelease) onRelease();
    }
    function handleStart(e){
      e.preventDefault();
      const t = e.touches? e.touches[0]: e;
      const r = joy.el.getBoundingClientRect();
      const centerX = r.left + r.width/2;
      const centerY = r.top + r.height/2;
      state.active=true;
      handleMove({touches:[{clientX:centerX, clientY:centerY}]}); // 先居中
      handleMove(e);
    }
    function handleMove(e){
      if (!state.active) return;
      const t = e.touches? e.touches[0]: e;
      const r = joy.el.getBoundingClientRect();
      const centerX = r.left + r.width/2;
      const centerY = r.top + r.height/2;
      const dx = t.clientX - centerX;
      const dy = t.clientY - centerY;
      setKnob(dx, dy);
      // Q/E 预览目标点
      if (state===touchQ || state===touchE){
        const isQ = (state===touchQ);
        const v = state.vec; const len = clamp(vlen(v), 0, 1);
        const ang = Math.atan2(v.y, v.x);
        const d = grenadeRange * len;
        touchPreviewWorld = {x: player.pos.x + Math.cos(ang)*d, y: player.pos.y + Math.sin(ang)*d};
        if (isQ) touchQ.preview = true; else touchE.preview = true;
      }
    }
    function handleEnd(e){ reset(); }
    joy.el.addEventListener('touchstart', handleStart, {passive:false});
    joy.el.addEventListener('touchmove', handleMove, {passive:false});
    joy.el.addEventListener('touchend', handleEnd, {passive:false});
    joy.el.addEventListener('touchcancel', handleEnd, {passive:false});
  }

  function createTouchControls(){
    if (!isTouch) return;
    const ui = document.getElementById('touchUI'); ui.style.display='block';
    // Move
    { const {el,knob}=makeJoy('移动'); ui.appendChild(el); touchMove.el=el; touchMove.knob=knob; bindJoy({el,knob}, touchMove); }
    // Fire (普攻)
    { const {el,knob}=makeJoy('普攻'); ui.appendChild(el); touchFire.el=el; touchFire.knob=knob; bindJoy({el,knob}, touchFire, ()=>{ mouse.left=false; }); }
    // Q
    { const {el,knob}=makeJoy('Q'); ui.appendChild(el); touchQ.el=el; touchQ.knob=knob;
      bindJoy({el,knob}, touchQ, ()=>{
        if (qCooldown<=0){
          const v = touchQ.vec; const len = clamp(vlen(v), 0, 1);
          if (len>0.05){
            const ang = Math.atan2(v.y, v.x);
            const d = grenadeRange * len;
            fireGrenadeTo(player.pos.x + Math.cos(ang)*d, player.pos.y + Math.sin(ang)*d);
            sfxGrenadeThrow(); initAudio(); qCooldown = 30;
          }
        }
        touchQ.preview = false;
      });
    }
    // E
    { const {el,knob}=makeJoy('E'); ui.appendChild(el); touchE.el=el; touchE.knob=knob;
      bindJoy({el,knob}, touchE, ()=>{
        const v = touchE.vec; const len = clamp(vlen(v), 0, 1);
        if (len>0.05){
          const ang = Math.atan2(v.y, v.x);
          const d = grenadeRange * len;
          fireFlashbangTo(player.pos.x + Math.cos(ang)*d, player.pos.y + Math.sin(ang)*d);
          sfxFlashThrow(); initAudio();
        }
        touchE.preview = false;
      });
    }
    positionTouchUI();
  }
  createTouchControls();

})();
</script>
</body>
</html>
